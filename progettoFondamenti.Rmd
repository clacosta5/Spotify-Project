---
title: "Progetto Fondamenti"
date: "`r Sys.Date()`"
css: stileProgetto.css
output:
  rmdformats::readthedown:
    highlight: kate
editor_options: 
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=FALSE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

# PRIMA LE COSE RICAVATE DAI DATI DI ASCOLTO RICHIESTI DI SPOTIFY

# POI SUI BRANI SALVATI

# ALLA FINE COSE USANDO SPOTIFYR

mi raccomanto, solo 10 minuti per la presentazione, massimo 12

PER FONDAMENTI RICAVARE DA TUTTI I BRANI SALVATI IN LIBRERIA IL GENERE E DA LI FARCI UN GRAFICOOO!!!!!!
-\> impossibile

che genere ascolto di più -\> circa fatto

in che periodo (esempio inizio lockdown cosa ascoltavo) -\> si

in che giorni ascolto di piu e in che ora  si

cio che ascolto io vs cio che ascoltano gli altri in italia/mondo

canzoni piu ascoltate in questo anno/ultimi mesi -\> DA METTERE?

quante volte ho ascoltato una determinata canzone!!!
il numero di volte -\> si

# Introduzione

## Cosa è Spotify?

parlare di Spotify?

le mie domande?

```{r pressure, echo=FALSE, fig.cap="Spotify Logo", out.width = "50%"}
knitr::include_graphics("img/spotifyLogo.png")
```

Spotify è un servizio musicale digitale (gratis o a pagamento) con il quale è semplice trovare la musica o il podcast giusto per ogni momento, su telefono, computer, tablet e altro ancora.

Ci sono milioni di brani ed episodi su Spotify.
Quindi, non importa cosa si stia facendo: quando si guida, ci si allena, si fa festa o ci si riposa, la musica e i podcast giusti sono sempre a portata di mano.

SI possono sfogliare le raccolte di amici, artisti e celebrità o creare delle tue playlist personali per ogni mood.

## Spotify Audio Analysis

Ogni brano ha delle particolari caratteristiche che lo rendono unico:

-   danceability: descrive quanto una canzone è adatta per ballare

-   energy: rappresenta una misura percettiva di intensità e attività (le tracce energiche sono veloci e rumorose)

-   valence: descrive la positività musicale trasmessa da un brano (alta valenza = più positive, bassa valenza = più negative)

I'm not going to get too much into this because there's tons of documentation to be found here, but to summarize; Spotify's API gives you the ability to extract several audio features of a song.
The available features that also have been used for this analysis are: - Danceability: Danceability describes how suitable a track is for dancing based on a combination of musical elements including tempo, rhythm stability, beat strength, and overall regularity.
A value of 0.0 is least danceable and 1.0 is most danceable.
- Acousticness: A measure from 0.0 to 1.0 of whether the track is acoustic.
- Energy: Energy is a measure from 0.0 to 1.0 and represents a perceptual measure of intensity and activity.
Typically, energetic tracks feel fast, loud, and noisy.
- Instrumentalness: Predicts whether a track contains no vocals.
The closer the instrumentalness value is to 1.0, the greater likelihood the track contains no vocal content.
- Liveness: Detects the presence of an audience in the recording.
Higher liveness values represent an increased probability that the track was performed live.
- Loudness: The overall loudness of a track in decibels (dB).
Loudness values are averaged across the entire track.
Values typical range between -60 and 0 db.
- Speechiness: Speechiness detects the presence of spoken words in a track.
The more exclusively speech-like the recording (e.g. talk show, audio book, poetry), the closer to 1.0 the attribute value.
- Tempo: The overall estimated tempo of a track in beats per minute (BPM).
In musical terminology, tempo is the speed or pace of a given piece and derives directly from the average beat duration.
- Valence: A measure from 0.0 to 1.0 describing the musical positiveness conveyed by a track.
Tracks with high valence sound more positive (e.g. happy, cheerful, euphoric), while tracks with low valence sound more negative (e.g. sad, depressed, angry).

## altro modo

KEY HELPER: POPULARITY: MEASURE THE POPULARITY BASED ON PLAY NUMBER OF THE TRACK VALENCE: A MEASURE OF HAPPINESS LIVENESS: DETECTS THE PRESENCE OF AN AUDIENCE IN THE RECORDING. SPEECHINESS: DETECTS THE PRESENCE OF SPOKEN WORDS IN A TRACK. ENERGY: REPRESENTS A PERCEPTUAL MEASURE OF INTENSITY AND ACTIVITY. DANCEABILITY: DESCRIBES HOW SUITABLE A TRACK IS FOR DANCING BASED

```{r}
#caricamento librerie
library(jsonlite)
library(lubridate)
library(gghighlight)
library(spotifyr)
library(tidyverse)
library(ggplot2)
library(plotly)
library(dplyr)
library(kableExtra)
library(formattable)
library(genius)
```

# Dataset

```{r}
#lettura dataset

#GUIDE
#https://towardsdatascience.com/explore-your-activity-on-spotify-with-r-and-spotifyr-how-to-analyze-and-visualize-your-stream-dee41cb63526
#https://rpubs.com/womeimingzi11/how_my_spotify_looks_like


streamHistory <- fromJSON("spotify_data/StreamingHistoryTotal.json", flatten = TRUE)
myLibrary <- fromJSON("spotify_data/secondRequest/YourLibrary.json", flatten = TRUE)
savedTracks <- myLibrary$tracks

# cambiare ora!!! perchè orario di greenwitch
#tz = a character string that specifies which time zone to parse the date with. The string must be a time zone that is #recognized by the user's OS.
a <- ymd_hm(streamHistory$endTime, tz = "Etc/GMT+0")
#cambio l'orario con quello del fuso di ROma
streamHistory2 <- streamHistory %>%
  mutate(endTime = with_tz(a, "Europe/Rome"))
```

## playback activity per week and hours

HackerRank è una società tecnologica che mette a disposizione di aziende e sviluppatori una piattaforma online con lo scopo di:

-   mettere in contatto le aziende con i migliori sviluppatori del mondo e viceversa;

-   agevolare le aziende nel processo di recruitamento dei candidati attraverso selezioni e sfide di coding;

-   offrire supporto didattico agli sviluppatori per affinare le proprie competenze;

Nel 2018 HackerRank ha sottoposto a oltre 25000 utenti, sia sviluppatori che responsabili delle assunzioni nelle aziende, un sondaggio online di 10 minuti per indagare sulle competenze, il background formativo, il ruolo attuale e altro ancora degli sviluppatori che hanno aderito, e sulle esigenze delle aziende al giorno d'oggi.

On what dates did you listen to more or less music on Spotify?
This is the first question that you could answer.
Starting from our variables, you can define the hours, minutes and seconds, and basically any temporality.
You can make a first plot to observe the behavior of your activity on Spotify throughout the year, per week for example.


# PLAYBACK ACTIVITY PER WEEK AND HOURS

```{r}
# ADDING DATE AND TIMING
# prova con i secondi
mySpotify = streamHistory2 %>% 
  as_tibble() %>% #as_tibble() turns an existing object, such as a data frame or matrix, into a so-called tibble, a data                   #frame with class tbl_df
  mutate_at("endTime", ymd_hms) %>%  #aggiungo i secondi
  mutate(date = floor_date(endTime, "day") %>% as_date, seconds = msPlayed / 1000, minutes = seconds / 60)
# date -> prendo la data e basta senza orario, ricavo secondi e minuti suonati


oreStreaming = mySpotify %>% 
  filter(date >= "2020-01-01") %>% 
  group_by(date) %>% 
  group_by(date = floor_date(date, "week")) %>%  # raggruppo per settimane
  summarize(ore = sum(minutes) / 60) %>%         # sommo i minuti di ogni settimana / 60 = ore
  #verb summarise() riduce più valori fino a un singolo riassunto
  arrange(date) %>%                              # metto in ordine di data crescente
  ggplot(aes(x = date, y = ore)) + 
  geom_col(aes(fill = ore)) +
  scale_fill_gradient(low = "blue", high = "red") + 
  labs(x= "data", y= "ore di ascolto") + 
  ggtitle("In che date ho ascoltato più o meno musica su Spotify?", "Attività di ascolto per settimana da aprile 2020 a aprile 2021")

ggplotly(oreStreaming)
```

As a result, you will get a plot like the following one, wherein in my case, the decrease in the use of Spotify after April is very visible.
Perhaps to a large extent, this is because in April 2020, when we were forced to work from home (and to date) by covid-19, the times when I most enjoyed listening to music were at the office, and today working at home we take turns playing each one their music on their platforms.

On what dates did you listen to more or less music by a specific artist?
Another question that you could answer in a very simple way and visualize with a line chart, you can also highlight the results you are looking for using the "gghighlight" library, and through the artistName variable.


# PLAYBACK ACTIVITY PER SPECIFIC ARTIST

```{r}
oreArtista <- mySpotify %>% 
  group_by(artistName, date = floor_date(date, "month")) %>%  #raggruppo per ascolto mensile
  summarize(hours = sum(minutes) / 60) %>% 
  ggplot(aes(x = date, y = hours, group = artistName)) +
  geom_line(aes(color = artistName)) +
  geom_point(aes(color = artistName)) +
  labs(x= "date", y= "ore di ascolto") + 
  ggtitle("In che mese ho ascoltato più o meno musica di uno specifico artista?" ,"prendo in considerazione: Taylor Swift, Lana Del Rey, Chase Atlantic, Lorde e blink-182") +
  gghighlight(artistName == "Taylor Swift" || artistName == "Lana Del Rey" || artistName == "Chase Atlantic" || artistName == "Lorde" || artistName == "blink-182") 

ggplotly(oreArtista)
```

What were the artists you listened to the most on your Spotify?
You can set a minimum of playing hours and find out from there which artists you listened to the most.
For example, let's say that you consider that the most listened to were those artists to whom you dedicated at least 3 hours of playback or more.
# MOST LISTENED ARTISTS (MORE THAN 10 HOURS)

```{r}

minutesMostListened <- mySpotify %>% 
  filter(date >= "2020-01-01") %>% 
  group_by(artistName) %>% 
  summarize(minutesListened = sum(minutes)) %>% 
  filter(minutesListened >= 600) %>%
  ggplot(aes(x = artistName, y = minutesListened)) + 
  geom_col(aes(fill = minutesListened, text = (minutesListened/60))) +
  scale_fill_gradient(low = "blue", high = "red") + 
  labs(x= "Artist", y= "Minutes of music playback") + 
  ggtitle("What were the most listened artists on my Spotify? (> 10 ore di ascolto)") +
  theme(axis.text.x = element_text(angle = 90))
ggplotly(minutesMostListened)
```

At what time have you had the most playback activity on your Spotify?
You could view by the hour of the day inclusive, the activity log of your complete history with a heatmap, to observe how this habit has changed over time if it is the case.
# PLAYBACK ACTIVITY BY DATE AND TIME OF DAY

```{r}

timeDay <- mySpotify %>% 
  filter(date >= "2020-01-01") %>% 
  group_by(date, hour = hour(endTime)) %>% 
  summarize(minutesListened = sum(minutes)) %>% 
  ggplot(aes(x = hour, y = date, fill = minutesListened)) + 
  geom_tile() + 
  labs(x= "Time of the day", y= "Date") + 
  ggtitle("When has there been more playback activity on my Spotify?", "Activity by date and time of day") +
  scale_fill_gradient(low = "green", high = "blue")
timeDay
```

You can also create a bar chart to take a closer look in detail at the times of the day when there is a record of the highest activity on your account.
# PLAYBACK ACTIVITY BY TIME OF THE DAY

```{r}

hoursDay <- mySpotify %>% 
  filter(date >= "2020-01-01") %>% 
  group_by(date, hour = hour(endTime), weekday = wday(date, label = TRUE))%>% 
  summarize(minutesListened = sum(minutes))
  hoursDay %>% 
  ggplot(aes(x = hour, y = minutesListened, group = date)) +
  geom_col(fill = "#66b2ff") +
  labs(x= "Time of the day", y= "Minutes of music playback") + 
  ggtitle("What time of day I've listened to the most music on Spotify?", "Activity from 0 to 24 hours")
  
```

What days of the week do you have the most playback activity on your Spotify?
You can also answer this question by creating another heatmap, but this time visualizing the relationship between day of the week and time of day.
# PLAYBACK ACTIVITY BY TIME OF THE DAY AND WEEKDAY

```{r}

giorno = hoursDay %>% 
  group_by(weekday, hour) %>% 
  summarize(minutes = sum(minutesListened)) %>% 
  ggplot(aes(x = hour, weekday, fill = minutes)) + 
  geom_tile() + 
  scale_fill_gradient(low = "green", high = "blue") +
  labs(x= "Time of the day", y= "Weekday") + 
  ggtitle("What weekday and time of day I've listened to the most music on Spotify?", "Weekly activity from 0 to 24 hours")

ggplotly(giorno)
```

Another way in which you can take a look at the details previously obtained could be by creating a line chart.
# PLAYBACK ACTIVITY BY TIME OF THE DAY AND WEEKDAY - LINE CHART

```{r}
weekDay <- hoursDay %>% 
  group_by(weekday, hour) %>% 
  summarize(minutes = sum(minutesListened)) %>% 
  ggplot(aes(x = hour, y = minutes, color = weekday)) + 
  geom_line() +
  labs(x= "Time of the day", y= "Minutes of music playback") + 
  ggtitle("What weekday and time of day I've listened to the most music on Spotify?", "Line chart - Weekly activity from 0 to 24 hours") 
weekDay
```

I can see in my case that Sundays are definitely the days that I listen to music the least.
You will get as a result a plot similar to the following one where you can also see which is the day when you have the least playback activity.

# PLAYBACK ACTIVITY BY DAY TYPE

```{r}
dayType <- hoursDay %>% 
  mutate(day_type = if_else(weekday %in% c("sab", "dom"), "weekend", "weekday")) %>% 
  group_by(day_type, hour) %>% 
  summarize(minutes = sum(minutesListened)) %>% 
  ggplot(aes(x = hour, y = minutes, color = day_type)) + 
  geom_line() +
  labs(x= "Time of the day", y= "Minutes of music playback") + 
  ggtitle("What day type I've listened to the most music on Spotify?", "Weekday and weekend activity from 0 to 24 hours") 
ggplotly(dayType)
```

```{r}
# aggiungo ultime canzoni di Lorde a mano fuck
savedTracks = savedTracks %>%
  add_row(artist = "Lorde", album = "Pure Heroine", track = "Buzzcut Season", uri = "spotify:track:3ShTaJBCOclymogQNzPde7") %>%
  add_row(artist = "Lorde", album = "Pure Heroine", track = "Glory And Gore", uri = "spotify:track:0SK9wxN40P6jlcMfTSAe0V") %>%
  add_row(artist = "Lorde", album = "Pure Heroine", track = "Still Sane", uri = "spotify:track:0t1D6NQt3uhZnam0yg8Wv3") %>%
  add_row(artist = "Lorde", album = "Pure Heroine", track = "White Teeth Teens", uri = "spotify:track:15LzvCtoJWwsrTWJMWUTOv") %>%
  add_row(artist = "Lorde", album = "Pure Heroine", track = "A World Alone", uri = "spotify:track:2HLnzsXJ3mD9UWAa3RY89n") %>%
  add_row(artist = "Lorde", album = "Pure Heroine", track = "Bravado", uri = "spotify:track:02ZorlDGq0uTnMobHNh4EL") %>%
  add_row(artist = "Lorde", album = "Pure Heroine", track = "Million DOllar Bills", uri = "spotify:track:3Lw7lWTJlcqlx8E9HFmByr") %>%
  add_row(artist = "Lorde", album = "Pure Heroine", track = "The Love Club", uri = "spotify:track:2yrJ1jWo3HLksJFUqUsZE4") %>%
  add_row(artist = "Lorde", album = "Pure Heroine", track = "Biting Down", uri = "spotify:track:45UvXCltvMpEPNLGzG0NYk") %>%
  add_row(artist = "Lorde", album = "Pure Heroine", track = "Swingin Party", uri = "spotify:track:7otV7kSzDMo11qLlw8pAtr") %>%
  add_row(artist = "Lorde", album = "The Hunger Games: Mockingjay Pt.1 (Original Motion Picture Soundtrack)", track = "Meltdown", uri = "spotify:track:27qvbQ10N5uoqXvYT9MqZt") %>%
  add_row(artist = "Lorde", album = "Caracal (Deluxe)", track = "Magnets", uri = "spotify:track:7nRmfGNhHKEEu5o8yFXLXt") %>%
  add_row(artist = "Lorde", album = "MTV Unplugged", track = "Don't Take The Money", uri = "spotify:track:25wTebB8ECapFHWRPywpYR") %>%
  add_row(artist = "Lorde", album = "Alternate Worlds", track = "Easy", uri = "spotify:track:0rkqMaZsWZzfdz4brrhS14") %>%
  add_row(artist = "Lorde", album = "The Hunger Games: Mockingjay Pt.1 (Original Motion Picture Soundtrack)", track = "Yellow Flicker Beat", uri = "spotify:track:0HVINS0AfIuck7csStOEHP")
  
```

# PROVA CON MY SAVED TRACKS!

```{r}
topArtistFromSavedTracks = savedTracks %>%
  group_by(artist) %>%
  count(artist) %>%
  arrange(-n)


  
  # PLOT TOP 10 ARTISTS BASED ON LIKED TRACKS
plotMyFavs <- topArtistFromSavedTracks %>%
  filter(n >= 11) %>%
  mutate(freq = case_when(n > 100 ~ '> 100 tracks',
      between(n, 50, 99) ~ '50-99 tracks',
      between(n, 20, 49) ~ '20-49 tracks',
      TRUE ~ '< 20 tracks')) %>%
  mutate(freq = factor(freq, levels = c('> 100 tracks', '50-99 tracks', '20-49 tracks', '< 20 tracks'))) %>%
  ggplot(mapping = aes(x = reorder(artist, -n), y = n, fill = freq)) +
  geom_col() +
  #scale_fill_brewer(palette="Spectral") +
  labs(x= "Artist name", y= "Number of tracks", fill = NULL) +
  ggtitle("What are my Top 10 favorite artists? Based on my ♥ tracks") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = -60),
        axis.title = element_text(face = 'bold'),
        plot.title = element_text(hjust = 0.5, face = 'bold', size = 15),
        plot.caption = element_text(hjust = 1,face = 'bold.italic'))
ggplotly(plotMyFavs)
#taylor complete collection: 267 brani
#lana comlete collection: 107 brani
```

# provo a capire quante volte ho ascoltato le canzoni su streamHistory2

```{r}
mostStreamedSongs = streamHistory2 %>%
  filter(msPlayed >= 50000) %>% #50 secondi
  group_by(trackName, artistName) %>%
  count(trackName) %>%
  arrange(-n) %>%
  filter(n >= 40)

mostStreamedArtist = mostStreamedSongs %>%
  group_by(artistName) %>%
  count(artistName) %>%
  arrange(-n)

#provo grafico, nei 2 assi n volte e titolo brano, colore artista
#n come colore?
#y frequenza e x top 50
#x artista, y numerosità

p <- mostStreamedSongs %>%
  ggplot(aes(x = reorder(trackName, -n), y = n, fill = artistName)) +
  geom_col() +
  theme(axis.text.x = element_blank())


ggplotly(p)
```

# carico librerie e get spotify authorization

```{r, include=FALSE}
# ESTABLISH CONNECTION SPOTIFY API
id = "00f22c2d4c35499bb29854c73ffdff97"
id_secret = "46d59a3db5514cdd93c1de05365e57c8"
#idVale = "bebf67dce2c54886b1171591e84eeb4b"
#id_secretVale = "f7bdc08240ca4cacbe576181d472c2f8"
Sys.setenv(SPOTIFY_CLIENT_ID = id)
Sys.setenv(SPOTIFY_CLIENT_SECRET = id_secret)
get_spotify_authorization_code()

access_token <- get_spotify_access_token()
```

## trova le MIE ultime 5 canzoni ascoltate!

```{r}
get_my_recently_played(limit = 5) %>% 
    mutate(artist.name = map_chr(track.artists, function(x) x$name[1]),
           played_at = as_datetime(played_at)) %>% 
    select(track.name, artist.name, track.album.name, played_at) %>% 
    kable() #funzione di knitr per creare tabelle

```

# artisti più ascoltati long term + grafico

```{r}
genereLong50 = get_my_top_artists_or_tracks(type = 'artists', time_range = 'long_term', limit = 50) %>%
    select(name, genres, popularity, followers.total) %>% 
    rowwise %>% 
    mutate(genres = paste(genres, collapse = ', ')) %>% 
    ungroup
#tolgo cose inutili
#write.csv(genereLong50,"genereLong50_2.csv", row.names = FALSE)
#riprendo dataframe
genereLong50Mod <- read.csv("genereLongg.csv")

top50 <- genereLong50Mod %>%
  ggplot(aes(x = popularity, y = followers.total, colour = name, genres = genres)) +
  geom_point()


ggplotly(top50, tooltip = c("x", "y", "colour", "genres"))
```

## artisti più ascoltati short term + modifiche + grafico GENERI

grafico cazzo

```{r}
# trova i MIEI artisti più ascoltati
genereShort = get_my_top_artists_or_tracks(type = 'artists', time_range = 'short_term') %>%
    select(name, genres, popularity, followers.total) %>% 
    rowwise %>% 
    mutate(genres = paste(genres, collapse = ', ')) %>% 
    ungroup


#mi copio la tabella perhcè viene modificata!
#write.csv(genereShort,"genereShort.csv", row.names = FALSE)

# GRAFICO GENERI TOP ARTISTI!!!
#modifico la tabella per avere tutti i generi come colonna
genereShort$pop = 0              #5
genereShort$postTeen.pop = 0     #6
genereShort$art.pop = 0          #7
genereShort$dance.pop = 0        #8
genereShort$electropop = 0       #9
genereShort$indie.pop = 0        #10
genereShort$uk.pop = 0           #11
genereShort$modern.rock = 0      #12
genereShort$pop.rock = 0         #13
genereShort$pop.rap = 0          #14
genereShort$RandB = 0            #15
genereShort$punk = 0             #16

# assegno ad ogni artista il genere esatto
#Tay
genereShort[1,5] = 1
genereShort[1,6] = 1
#Lorde
genereShort[2,7] = 1
genereShort[2,8] = 1
genereShort[2,9] = 1
genereShort[2,5] = 1
genereShort[2,6] = 1
#Sasha Sloan
genereShort[3,9] = 1
genereShort[3,10] = 1
genereShort[3,5] = 1
genereShort[3,6] = 1
#OLIVIA
genereShort[4,5] = 1
#TOVE LO
genereShort[5,8] = 1
genereShort[5,9] = 1
genereShort[5,5] = 1
genereShort[5,6] = 1
genereShort[5,14] = 1
#LANA
genereShort[6,7] = 1
genereShort[6,5] = 1
#ANNE MARIE
genereShort[7,8] = 1
genereShort[7,5] = 1
genereShort[7,6] = 1
genereShort[7,11] = 1
#CHASE ATLANTIC
genereShort[8,12] = 1
genereShort[8,5] = 1
#HAIM AVRIL
genereShort[9,5] = 1
genereShort[9,6] = 1
genereShort[9,8] = 1
#HAIM
genereShort[10,7] = 1
genereShort[10,8] = 1
genereShort[10,10] = 1
genereShort[10,13] = 1
#BILLIE
genereShort[11,9] = 1
genereShort[11,5] = 1
#Demi Lovato
genereShort[12,5] = 1
genereShort[12,6] = 1
genereShort[12,8] = 1
#Dua Lipa
genereShort[13,8] = 1
genereShort[13,5] = 1
genereShort[13,11] = 1
#Sleeping At Last
genereShort[14,5] = 1
genereShort[14,10] = 1
genereShort[14,13] = 1
#FLETCHER
genereShort[15,8] = 1
genereShort[15,9] = 1
genereShort[15,5] = 1
genereShort[15,6] = 1
genereShort[15,10] = 1
#THE WEEKND
genereShort[16,5] = 1
genereShort[16,15] = 1
#Halsey
genereShort[17,8] = 1
genereShort[17,9] = 1
genereShort[17,5] = 1
genereShort[17,6] = 1
genereShort[17,10] = 1
#Rita Ora
genereShort[18,8] = 1
genereShort[18,9] = 1
genereShort[18,14] = 1
genereShort[18,6] = 1
genereShort[18,11] = 1
#BLINK 182
genereShort[19,16] = 1
#KHALID
genereShort[20,5] = 1
#totale, aggiungo una nuova riga alla fine con il totale per i vari generi
#genereShort <- genereShort %>%
#  add_row(name = "Totale", genres = "/", popularity = 0, followers.total = 0, pop = 17, postTeen.pop = 11, art.pop = 3, #dance.pop = 11, electropop = 7, indie.pop = 5, uk.pop = 4, modern.rock = 1, pop.rock = 2, pop.rap = 2, RandB = 1, punk #= 1)

#creo un nuovo dataframe per fare un grafico sui generi più ascoltati recentemente
nome <- c("pop", "post-teen pop", "art pop", "dance pop", "electropop", "indie pop", "uk pop", "modern rock", "pop rock", "pop rap", "r&b", "punk")
tot <- c(17, 10, 3, 10, 7, 5, 3, 1, 2, 2, 1, 1)

gen <- data.frame(nome, tot)

grafGen <- gen %>%
  ggplot(aes(x = nome, y = tot)) +
  ggtitle("Generi più riprodotti ultimamente") +
  #theme_dark() +
  geom_col(aes(fill = nome)) +
  labs(x = "genere", y = "totale per genere") +
  theme(axis.text.x = element_text(angle = 90), plot.title = element_text(face = "italic"))
#plot.background = element_rect(fill = "green")



ggplotly(grafGen)

#netta maggioranza per il pop ma è presente anche rock e punk!

```

netta maggioranza per il pop ma è presente anche rock e punk!
